<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.Button?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.Font?>

<AnchorPane id="AnchorPane" prefHeight="600.0" prefWidth="700.0" xmlns="http://javafx.com/javafx/8.0.141" xmlns:fx="http://javafx.com/fxml/1" fx:controller="learnalgo.DesHeapController">
   <children>
      <TextArea editable="false" layoutX="3.0" layoutY="4.0" prefHeight="600.0" prefWidth="700.0" text="Heap sort is simple to implement, performs an O(n·lg(n)) in-place sort, but is not stable.&#10;&#10;The first loop, the Θ(n) “heapify” phase, puts the array into heap order. The second loop, the O(n·lg(n)) “sortdown” phase, repeatedly extracts the maximum and restores heap order.&#10;&#10;The sink function is written recursively for clarity. Thus, as shown, the code requires Θ(lg(n)) space for the recursive call stack. However, the tail recursion in sink() is easily converted to iteration, which yields the O(1) space bound.&#10;&#10;Both phases are slightly adaptive, though not in any particularly useful manner. In the nearly sorted case, the heapify phase destroys the original order. In the reversed case, the heapify phase is as fast as possible since the array starts in heap order, but then the sortdown phase is typical. In the few unique keys case, there is some speedup but not as much as in shell sort or 3-way quicksort." wrapText="true">
         <font>
            <Font name="System Bold" size="12.0" />
         </font>
      </TextArea>
      <Button layoutX="629.0" layoutY="559.0" mnemonicParsing="false" onAction="#backButtonAction" text="BACK" />
   </children>
</AnchorPane>
