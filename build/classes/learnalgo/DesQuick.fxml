<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.Button?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.Font?>

<AnchorPane id="AnchorPane" prefHeight="600.0" prefWidth="700.0" xmlns="http://javafx.com/javafx/8.0.141" xmlns:fx="http://javafx.com/fxml/1" fx:controller="learnalgo.DesQuickController">
   <children>
      <TextArea layoutX="251.0" layoutY="6.0" prefHeight="596.0" prefWidth="449.0" />
      <Button layoutX="612.0" layoutY="547.0" mnemonicParsing="false" onAction="#backButtonAction" prefHeight="32.0" prefWidth="60.0" text="BACK" />
      <ImageView fitHeight="39.0" fitWidth="373.0" layoutX="258.0" layoutY="14.0" pickOnBounds="true" preserveRatio="true">
         <image>
            <Image url="@Image/quick1.PNG" />
         </image>
      </ImageView>
      <ImageView fitHeight="403.0" fitWidth="357.0" layoutX="272.0" layoutY="65.0" pickOnBounds="true" preserveRatio="true">
         <image>
            <Image url="@Image/quick-2.PNG" />
         </image>
      </ImageView>
      <ImageView fitHeight="128.0" fitWidth="389.0" layoutX="258.0" layoutY="476.0" pickOnBounds="true" preserveRatio="true">
         <image>
            <Image url="@Image/quick3.PNG" />
         </image>
      </ImageView>
      <TextArea editable="false" layoutX="3.0" prefHeight="596.0" prefWidth="248.0" text="The quick sort uses divide and conquer to gain the same advantages as the merge sort, while not using additional storage. As a trade-off, however, it is possible that the list may not be divided in half. When this happens, we will see that performance is diminished.&#10;&#10;A quick sort first selects a value, which is called the pivot value. Although there are many different ways to choose the pivot value, we will simply use the first item in the list. The role of the pivot value is to assist with splitting the list. The actual position where the pivot value belongs in the final sorted list, commonly called the split point, will be used to divide the list for subsequent calls to the quick sort.&#10;&#10;&#10;Figure-1  shows that 54 will serve as our first pivot value. Since we have looked at this example a few times already, we know that 54 will eventually end up in the position currently holding 31. The partitionprocess will happen next. It will find the split point and at the same time move other items to the appropriate side of the list, either less than or greater than the pivot value.&#10;&#10;&#10;Partitioning begins by locating two position markers—let’s call them leftmark and rightmark —at the beginning and end of the remaining items in the list (positions 1 and 8 in ). The goal of the partition process is to move items that are on the wrong side with respect to the pivot value while also converging on the split point. Figure-2 shows this process as we locate the position of 54.&#10;&#10;&#10;We begin by incrementing  leftmark  until we locate a value that is greater than the pivot value. We then decrement  rightmark  until we find a value that is less than the pivot value. At this point we have discovered two items that are out of place with respect to the eventual split point. For our example, this occurs at 93 and 20. Now we can exchange these two items and then repeat the process again.&#10;&#10;At the point where rightmark becomes less than leftmark, we stop. The position of  rightmark  is now the split point. The pivot value can be exchanged with the contents of the split point and the pivot value is now in place (Figure-3). In addition, all the items to the left of the split point are less than the pivot value, and all the items to the right of the split point are greater than the pivot value. The list can now be divided at the split point and the quick sort can be invoked recursively on the two halves.&#10;&#10;&#10;&#10;" wrapText="true">
         <font>
            <Font name="System Bold" size="12.0" />
         </font>
      </TextArea>
   </children>
</AnchorPane>
